import { Persistor } from "../../utils/persistor.ts";
import { CVEInfos, InfoChunk } from "./type.ts";

export class CVEInfosHandler {
  infosPersistor: Persistor<CVEInfos, { id: string }>;
  constructor(infosPersistor: Persistor<CVEInfos, { id: string }>) {
    this.infosPersistor = infosPersistor;
  }

  // TODO: implem
  async getMissingDataChunks() {
  }

  // TODO: implem
  async getMissingDataChunksFor(year: number) {
  }

  /**
   * Returns the chunks to fetch
   *
   * TODO: this is not the correct implementation for now
   */
  async getLastChunk() {
    const res = await this.infosPersistor.findOne({ id: "cves" });
    const k = Object.keys(res?.chunks || {}).sort().reverse();
    // last year
    let lastKey: undefined | string = undefined;
    if (k.length > 0) {
      lastKey = k[0];
    }
    if (!lastKey) {
      return undefined;
    }
    // todo: type is incomplete here
    const chunks = res!.chunks[lastKey];
    if (chunks.length > 0) {
      chunks.sort((a, b) => a.end.getTime() - b.end.getTime());
      return chunks[0];
    }
    return undefined;
  }

  async ensureChunksIntegrity(until: Date) {
    // check that all chunks exists unitl the "until" date
    // TODO: implem, that missing chunk is only from until -> now
  }

  async ensureInfosExist() {
    const res = await this.infosPersistor.findOne({ id: "cves" });
    console.log('res', res);
    if (!res) {
      await this.infosPersistor.persistOne({
        id: "cves",
        chunks: {
          // years are automaticcally upserted
        },
      });
      console.log('created res');
      console.log(await this.infosPersistor.findOne({ id: "cves" }));
    }

  }
}
