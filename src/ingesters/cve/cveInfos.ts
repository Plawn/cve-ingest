import { Persistor } from "../../utils/persistor.ts";
import { InfoChunk } from "./type.ts";


export class CVEInfosHandler {
  infosPersistor: Persistor<InfoChunk, { id: string }>;
  constructor(infosPersistor: Persistor<InfoChunk, { id: string }>) {
    this.infosPersistor = infosPersistor;
  }

  // TODO: implem
  async getMissingDataChunks() {
  }

  // TODO: implem
  async getMissingDataChunksFor(year: number) {
  }

  /**
   * Returns the chunks to fetch
   *
   * TODO: this is not the correct implementation for now
   */
  async getLastChunk() {
    const res = await infos.findOne({ id: "cves" });
    const k = Object.keys(res?.chunks).sort().reverse();
    let lastKey: undefined | string = undefined;
    if (k.length > 0) {
      lastKey = k[0];
    }
    if (!lastKey) {
      return undefined;
    }
    // todo: type is incomplete here
    const chunks: Array<{ end: Date; start: Date }> = res!.chunks[lastKey];
    if (chunks.length > 0) {
      chunks.sort((a, b) => a.end.getTime() - b.end.getTime());
      return chunks[0];
    }
    return undefined;
  }

  async ensureChunksIntegrity(until: Date) {
    // check that all chunks exists unitl the "until" date
    // TODO: implem, that missing chunk is only from until -> now
  }

  async ensureInfosExist() {
    const res = await infos.findOne({ id: "cves" });
    if (!res) {
      await infos.insertOne({
        id: "cves",
        chunks: {
          // years are automaticcally upserted
        },
      });
    }
  }

}