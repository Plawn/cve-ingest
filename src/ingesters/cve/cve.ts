import { OldCompatCVEInfos } from "../../index.ts";
import { CPE } from "../cpe/type.ts";
import { newDb } from "./../../conf.ts";
import { Batcher, SimpleBatcher } from "./../../utils/batcher.ts";
import { prepareDate } from "./../../utils/format.ts";
import { Persistor } from "./../../utils/persistor.ts";
import { Counter, PoolExecutor, sleep } from "./../../utils/pool.ts";
import { ProgressHandler } from "./../../utils/progress.ts";
import {
  Chunk,
  CVENVD,
  CVENVDResult,
  CVESearch,
  ExportedCVESearch,
} from "./../../utils/types.ts";
import { getDateChunks } from "./../../utils/utils.ts";
import { CVEInfosHandler } from "./cveInfos.ts";
import {
  addIfMissing,
  extractVendorAndProduct,
  handleCWE,
  handleDescription,
  handleReferences,
  handleV2Metrics,
  handleV3Metrics,
  makeBase,
  makeQueryId,
  prepareQuery,
  stem,
} from "./format.ts";
import { CVEInfos, InfoChunk, UpdateProps } from "./type.ts";

export const defaultValues = {
  cwe: "Unknown",
};

// todo remove all of this
// only one db
const infos = newDb.collection("infos");

const pageSize = 2000;

async function getCvesBetweenPaged(
  start: Date,
  end: Date,
  page: number,
  pageSize: number,
): Promise<CVENVDResult> {
  const startString = prepareDate(start);
  const endString = prepareDate(end);
  const startIndex = page * pageSize;
  const url =
    `https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=${startString}&lastModEndDate=${endString}&startIndex=${startIndex}`;
  console.log("using url", url);
  while (true) {
    const res = await fetch(url);
    const text = await res.text();
    if (res.status === 403) {
      console.log('warn: going too fast');
      await sleep(10_000);
    } else {
      try {
        const value = JSON.parse(text);
        return value;
      } catch (e) {
        console.error(res.status, text);
        throw e;
      }
    }
  }
}

// in Days
const timeChukSize = 30;

async function* getCvesBetween(
  baseStart: Date,
  baseEnd: Date,
): AsyncGenerator<Chunk> {

  for (const [start, end] of getDateChunks(baseStart, baseEnd, timeChukSize)) {
    let hasRemaining = true;
    let page = 0;

    while (hasRemaining) {
      const result = await getCvesBetweenPaged(start, end, page, pageSize);
      // if the result is exactly the size of the page then we waste one query
      hasRemaining = !(result.vulnerabilities.length < pageSize);
      const expectedPages = result.totalResults / pageSize;
      page++;
      yield { result, page, expectedPages, start, end, hasRemaining };
    }
  }
}
async function handleOne(
  item: CVENVD,
  handleCPE: (item: CVENVD, cve: CVESearch) => Promise<void>,
): Promise<ExportedCVESearch> {
  const cve = makeBase(item);
  handleDescription(item, cve);
  handleV3Metrics(item, cve);
  handleV2Metrics(item, cve);
  handleReferences(item, cve);
  handleCWE(item, cve);
  cve["vulnerable_configuration_cpe_2_2"] = [];

  await handleCPE(item, cve);

  return {
    ...cve,
    vulnerable_product_stems: [...cve.vulnerable_product_stems],
    products: [...cve.products],
    vendors: [...cve.vendors],
    vulnerable_configuration: [...cve.vulnerable_configuration],
    vulnerable_product: [...cve.vulnerable_product],
    vulnerable_configuration_stems: [...cve.vulnerable_configuration_stems],
  };
}

function getUpdatedCvesSince(start: Date, upTo: Date) {
  const cves = getCvesBetween(start, upTo);
  return cves;
}

async function doOnePage(
  chunk: Chunk,
  counter: Counter,
  // pendingPages: Counter,
  batcher: Batcher<unknown>,
  progressHandler: ProgressHandler<Date>,
  handleCPE: (item: CVENVD, cve: CVESearch) => Promise<void>,
) {
  const {
    result,
    page,
    start: chunkSart,
    end: chunkEnd,
    expectedPages,
    hasRemaining,
  } = chunk;
  console.log("doing page", page, "of expected pages", expectedPages);
  const start = new Date().getTime();
  // add streaming here maybe
  const re = result.vulnerabilities
    .map((c) =>
      handleOne(c.cve, handleCPE)
        .then((e) => {
          batcher.enqueue(e);
          counter.increment();
        })
    );
  await Promise.all(re);
  const end = new Date().getTime();
  const took = (end - start) / 1000;
  console.log(`page ${page} took ${took} s`);
  progressHandler.addChunk({
    itemCount: re.length,
    start: chunkSart,
    end: chunkEnd,
    done: !hasRemaining,
    count: page,
    getBucketId: () => `${chunkSart}${chunkEnd}`,
  });
}

const getGenerator = (since: Date, upTo: Date, props?: UpdateProps) => {
  if (props) {
    return getCvesBetween(props.startDate, props.endDate);
  } else {
    return getUpdatedCvesSince(since, upTo);
  }
};


const EARLIEST_DATE = new Date('01-01-1999');

export class CVEIngester {
  cvePersistor: Persistor<ExportedCVESearch, { id: string }>;
  infosPersistor: Persistor<CVEInfos, { id: string }>;
  progressHandler: ProgressHandler<Date>;
  cpePersistor: Persistor<CPE, { id: string }>;
  cveInfos: CVEInfosHandler;
  oldInfoPersistor: Persistor<OldCompatCVEInfos, { db: string; }>;

  constructor(
    cvePersistor: Persistor<ExportedCVESearch, { id: string }>,
    cpePersistor: Persistor<CPE, { id: string }>,
    infosPersistor: Persistor<CVEInfos, { id: string }>,
    oldInfoPersistor: Persistor<OldCompatCVEInfos, { db: string }>
  ) {
    this.cvePersistor = cvePersistor;
    this.infosPersistor = infosPersistor;
    this.cpePersistor = cpePersistor;
    this.cveInfos = new CVEInfosHandler(infosPersistor);
    this.oldInfoPersistor = oldInfoPersistor;

    this.progressHandler = new ProgressHandler<Date>(
      async ({ start, end, total }) => {
        const now = new Date();
        console.log("one chunk done at", now);
        // implement execute operation
        await infos.updateOne({ id: "cves" }, {
          // start and end have to be in same year so we can bucket chunks by year
          $push: {
            [`chunks.${start.getUTCFullYear()}`]: {
              start,
              end,
              at: now,
              itemCount: total,
            },
          },
        });
      },
    );
  }

  // TODO: add client opening + closing
  // TODO: implem cleaner and not global client
  populateCves = async (props?: UpdateProps) => {
    await this.cveInfos.ensureInfosExist(); // ensure collection exists in mongo

    const counter = new Counter();
    const upTo = new Date();
    const dbLastChunk = await this.cveInfos.getLastChunk();
    const lastChunk: InfoChunk = dbLastChunk || { start: EARLIEST_DATE, end: EARLIEST_DATE, itemCount: 0, at: new Date() };
    const pool = new PoolExecutor(2);
    const start = new Date().getTime();
    const batchers: Batcher<unknown>[] = [];

    for await (const r of getGenerator(lastChunk.end, upTo, props)) {
      const batcher = new SimpleBatcher(1000, this.flusher, pool);
      batchers.push(batcher);
      pool.submit(() =>
        doOnePage(r, counter, batcher, this.progressHandler, this.handleCPE)
      );
    }
    console.log("all download done, waiting for handlers to finish");
    await pool.isEmpty();
    await Promise.all(batchers.map((e) => e.flush()));

    const end = new Date().getTime();
    const took = (end - start) / 1000;

    console.log(`done: ${counter.get()} in ${took} s`);
    console.log(`did ${counter.get() / took} items/s`);

    // await this.cveInfos.ensureChunksIntegrity(upTo); // checking that all the data does exist
    await this.oldInfoPersistor.persistOne({
      db: "cves",
      "last-modified": upTo,
    });
  };

  protected flusher = async (batch: ExportedCVESearch[]) => {
    const size = batch.length;
    if (size === 0) {
      return;
    }
    const start = new Date().getTime();
    // TODO: replace with persistor use
    const batchInsertResult = await this.cvePersistor.persistMany(batch);

    const end = new Date().getTime();
    console.log("batch insert took", end - start, "for", batchInsertResult);
  };

  /**
   * Todo => type the return of this
   * @param query
   * @returns
   */
  getCPEInfos = (query: any) => {
    return this.cpePersistor.findOne(query);
  }

  handleCPE = async (item: CVENVD, cve: CVESearch) => {
    if ("configurations" in item) {
      for (const i of item.configurations.flatMap((e) => e.nodes)) {
        for (const cpeMatch of i.cpeMatch) {
          if (cpeMatch.vulnerable) {
            const [query, versionInfo] = await prepareQuery(cpeMatch);
            if (query) {
              query["id"] = makeQueryId(cpeMatch.criteria, versionInfo);
              const cpeInfos = await this.getCPEInfos(query);
              if (cpeInfos) {
                cpeInfos.cpe_name.map((e) => e.cpe23Uri)
                  .forEach((cpe23Uri) => {
                    addIfMissing(cve, "vulnerable_product", cpe23Uri);
                    addIfMissing(cve, "vulnerable_configuration", cpe23Uri);
                    addIfMissing(
                      cve,
                      "vulnerable_configuration_stems",
                      stem(cpe23Uri),
                    );
                    const [vendor, product] = extractVendorAndProduct(cpe23Uri);
                    addIfMissing(cve, "vendors", vendor);
                    addIfMissing(cve, "products", product);
                    const preparedStem = stem(cpe23Uri);
                    addIfMissing(cve, "vulnerable_product_stems", preparedStem);
                  });
              } else {
                // TODO: implem
              }
            }
          }
        }
      }
    }
  }
}
