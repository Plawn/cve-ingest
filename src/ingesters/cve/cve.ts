import { CPE } from "../cpe/type.ts";
import { Batcher, SimpleBatcher } from "./../../utils/batcher.ts";
import { prepareDate } from "./../../utils/format.ts";
import { Persistor } from "./../../utils/persistor.ts";
import { Counter, PoolExecutor, sleep, toMs } from "./../../utils/pool.ts";
import { ProgressHandler } from "./../../utils/progress.ts";
import {
  CveChunk,
  CVENVD,
  CVENVDResult,
  CVESearch,
  ExportedCVESearch,
  Update,
} from "./../../utils/types.ts";
import { getDateChunks } from "./../../utils/utils.ts";
import {
  addIfMissing,
  extractVendorAndProduct,
  handleCWE,
  handleDescription,
  handleReferences,
  handleV2Metrics,
  handleV3Metrics,
  makeBase,
  makeQueryId,
  prepareQuery,
  stem,
} from "./format.ts";
import { UpdateProps } from "./type.ts";

export const defaultValues = {
  cwe: "Unknown",
};

// todo remove all of this
// only one db
// const infos = newDb.collection("infos");

const pageSize = 2000;

async function getCvesBetweenPaged(
  start: Date,
  end: Date,
  page: number,
  pageSize: number,
): Promise<CVENVDResult> {
  const startString = prepareDate(start);
  const endString = prepareDate(end);
  const startIndex = page * pageSize;
  const url =
    `https://services.nvd.nist.gov/rest/json/cves/2.0/?lastModStartDate=${startString}&lastModEndDate=${endString}&startIndex=${startIndex}`;
  console.log("using url", url);
  for (; ;) {
    const res = await fetch(url);
    try {
      const text = await res.text();
      if (res.status > 300) {
        console.log("warn: going too fast");
        await sleep(toMs(10_000));
      } else {
        try {
          const value = JSON.parse(text);
          return value;
        } catch (_e) {
          console.error(res.status, text);
          // throw e;
        }
      }
    } catch (e) {
      console.error(res.status, e);
    }
  }
}

// in Days
const timeChukSize = 30;

async function* getCvesBetween(
  baseStart: Date,
  baseEnd: Date,
): AsyncGenerator<CveChunk> {
  for (const [start, end] of getDateChunks(baseStart, baseEnd, timeChukSize)) {
    let hasRemaining = true;
    let page = 0;

    while (hasRemaining) {
      const result = await getCvesBetweenPaged(start, end, page, pageSize);
      // if the result is exactly the size of the page then we waste one query
      hasRemaining = !(result.vulnerabilities.length < pageSize);
      const expectedPages = result.totalResults / pageSize;
      page++;
      yield { result, page, expectedPages, start, end, hasRemaining };
    }
  }
}
async function handleOne(
  item: CVENVD,
  handleCPE: (item: CVENVD, cve: CVESearch) => Promise<void>,
): Promise<ExportedCVESearch> {
  const cve = makeBase(item);
  handleDescription(item, cve);
  handleV3Metrics(item, cve);
  handleV2Metrics(item, cve);
  handleReferences(item, cve);
  handleCWE(item, cve);
  cve["vulnerable_configuration_cpe_2_2"] = [];

  await handleCPE(item, cve);

  return {
    ...cve,
    vulnerable_product_stems: [...cve.vulnerable_product_stems],
    products: [...cve.products],
    vendors: [...cve.vendors],
    vulnerable_configuration: [...cve.vulnerable_configuration],
    vulnerable_product: [...cve.vulnerable_product],
    vulnerable_configuration_stems: [...cve.vulnerable_configuration_stems],
  };
}

function getUpdatedCvesSince(start: Date, upTo: Date) {
  const cves = getCvesBetween(start, upTo);
  return cves;
}

async function doOnePage(
  chunk: CveChunk,
  counter: Counter,
  // pendingPages: Counter,
  batcher: Batcher<unknown>,
  progressHandler: ProgressHandler<Date>,
  handleCPE: (item: CVENVD, cve: CVESearch) => Promise<void>,
) {
  const {
    result,
    page,
    start: chunkSart,
    end: chunkEnd,
    expectedPages,
    hasRemaining,
  } = chunk;
  console.log("doing page", page, "of expected pages", expectedPages);
  const start = new Date().getTime();
  // add streaming here maybe
  const re = result.vulnerabilities
    .map((c) =>
      // handleOne ça mets les infos dans l'item cve au bon endroit etc 
      handleOne(c.cve, handleCPE)
        .then((e) => {
          // Pas besoin de ça vu qu'on fait tout à la suite (en soit aujourd'hui vu comment ça marche, il faut enqueue pour qu'ensuite le flush, il aille chercher les éléments pour bien les rajouter dans la DB)
          batcher.enqueue(e);
          counter.increment();
        })
    );
  // TODO Comprendre ce que ça fait vraiment ça. On attend que toutes les nouvelles entrées soient terminées d'être traitées là c'est ça ?
  await Promise.all(re);
  const end = new Date().getTime();
  const took = (end - start) / 1000;
  console.log(`page ${page} took ${took} s`);
  // ça je me dis que le garder peut être  intéressant si le script crash au milieu d'une exec, on peut repartir propre
  progressHandler.addChunk({
    itemCount: re.length,
    start: chunkSart,
    end: chunkEnd,
    done: !hasRemaining,
    count: page,
    getBucketId: () => `${chunkSart}${chunkEnd}`,
  });
}

const getGenerator = (since: Date, upTo: Date, props?: UpdateProps) => {
  if (props) {
    return getCvesBetween(props.startDate, props.endDate);
  } else {
    return getUpdatedCvesSince(since, upTo);
  }
};

const EARLIEST_DATE = new Date("01-01-1999");

const defaultChunk = {
  start: EARLIEST_DATE,
  end: EARLIEST_DATE,
  itemCount: 0,
  at: new Date(),
};
// TODO : Voir ce qu'on fait avec ce progressHandler 
// Par exemple donner un compteur, ou tout simplement supprimer ces fonctions
const getProgressHandler = (db?: Db) => {
  if (db) {
    const infos = db.collection("infos");
    return new ProgressHandler<Date>(
      async ({ start, end, total }) => {
        const now = new Date();
        console.log("one chunk done at", now);
        // implement execute operation
        await infos.updateOne({ id: "cves" }, {
          // start and end have to be in same year so we can bucket chunks by year
          $push: {
            [`chunks.${start.getUTCFullYear()}`]: {
              start,
              end,
              at: now,
              itemCount: total,
            },
          },
        });
      },
    );
  } else {
    return new ProgressHandler<Date>(
      // deno-lint-ignore require-await no-unused-vars
      async ({ start, end, total }) => {
        const now = new Date();
        console.log("one chunk done at", now);
      },
    );
  }
};

function handleProductAndVendor(cve: CVESearch, s: string) {
  const [vendor, product] = extractVendorAndProduct(s);
  addIfMissing(cve, "vendors", vendor);
  addIfMissing(cve, "products", product);
}

export class CVEIngester {
  protected readonly cvePersistor: Persistor<ExportedCVESearch, { id: string }>;
  protected readonly progressHandler: ProgressHandler<Date>;
  protected readonly cpePersistor: Persistor<CPE, { id: string }>;
  protected readonly updatePersistor: Persistor<
    Update,
    { id: string }
  >;

  constructor(
    cvePersistor: Persistor<ExportedCVESearch, { id: string }>,
    cpePersistor: Persistor<CPE, { id: string }>,
    updatePersistor: Persistor<Update, { id: string }>,
  ) {
    this.cvePersistor = cvePersistor;
    this.cpePersistor = cpePersistor;
    this.updatePersistor = updatePersistor;
    //this.progressHandler = getProgressHandler(db);
  }

  // TODO: add client opening + closing
  // TODO: implem cleaner and not global client
  populateCves = async (props?: UpdateProps) => {
    //await this.cveInfos.ensureInfosExist(); // ensure collection exists in mongo

    const counter = new Counter();
    const upTo = new Date();
    // On récupère la date de dernière modification, l'id 2 pointant sur la date dernière modif des CVEs
    const dbLastUpdate = await this.updatePersistor.findOne({id: "2"});
    console.log(dbLastUpdate?.last_update);
    // Avant C'était 2, avec 1, je rends ça séquentiel, plus simple à traiter
    // Il faudrait traiter en mode séquentiel, donc plus besoin de pool, ni de batcher
    const pool = new PoolExecutor(1);
    const start = new Date().getTime();
    const batcher = new SimpleBatcher(1000, this.flusher, pool);
    // Si on n'a pas d'entrée pour la dernière maj, on fait du 01/01/1900 à upTo
    for await (const r of getGenerator(new Date("01-01-1999"), upTo, undefined)) {
      // ça c'est avec le pool, je veux le faire séquentiellement maintenant
      pool.submit(() =>
        doOnePage(r, counter, batcher, this.progressHandler, this.handleCPE)
      );

      // TODO Proposition séquentielle à voir
      // Au lieu de submit une pool, on la process directement

    }
    console.log("all download done, waiting for handlers to finish");
    await pool.isEmpty();
    // C'est cette fonction qui va faire les persist de tous les batchs à la fin.
    await batcher.flush();

    const end = new Date().getTime();
    const took = (end - start) / 1000;

    console.log(`done: ${counter.get()} in ${took} s`);
    console.log(`did ${counter.get() / took} items/s`);

    // On ne vérifie pas l'intégrité de chaque chunk ==> pourquoi si le code existe ?? 
    // await this.cveInfos.ensureChunksIntegrity(upTo); // checking that all the data does exist
    await this.updatePersistor.persistOne({
      id: "2",
      "last_update": upTo,
    });
  };

  protected flusher = async (batch: ExportedCVESearch[]) => {
    const size = batch.length;
    if (size === 0) {
      return;
    }
    const start = new Date().getTime();
    // TODO: replace with persistor use
    const batchInsertResult = await this.cvePersistor.persistMany(batch);

    const end = new Date().getTime();
    console.log("batch insert took", end - start, "for", batchInsertResult);
  };

  /**
   * Todo => type the return of this
   * @param query
   * @returns
   */
  // deno-lint-ignore no-explicit-any
  getCPEInfos = (query: any) => {
    return this.cpePersistor.findOne(query);
  };

  // TODO : Demander à Paul comment ça marche les addifmissing sur les cves, et comment ça part après
  handleConfiguration = async (item: CVENVD, cve: CVESearch) => {
    if ("configurations" in item) {
      for (const i of item.configurations.flatMap((e) => e.nodes)) {
        if (!Array.isArray(i.cpeMatch)) {
          console.error("error", i, item.id, item.configurations);
          continue;
        }
        for (const cpeMatch of i.cpeMatch) {
          const criteria = cpeMatch.criteria; // same as cpe_uri from cve-search
          if (cpeMatch.vulnerable) {
            const [query, versionInfo] = await prepareQuery(cpeMatch);
            if (query) {
              const queryId = makeQueryId(criteria, versionInfo);
              query["id"] = queryId;
              const cpeInfos = await this.getCPEInfos(query);
              cve.cpe_id = queryId;
              if (cpeInfos) {
                if (cpeInfos.cpe_name.length ) {
                  cpeInfos.cpe_name.map((e) => e.cpe23Uri)
                    .forEach((cpe23Uri) => {
                      addIfMissing(cve, "vulnerable_product", cpe23Uri);
                      addIfMissing(cve, "vulnerable_configuration", cpe23Uri);
                      addIfMissing(
                        cve,
                        "vulnerable_configuration_stems",
                        stem(cpe23Uri),
                      );
                      handleProductAndVendor(cve, cpe23Uri);
                      const preparedStem = stem(cpe23Uri);
                      addIfMissing(
                        cve,
                        "vulnerable_product_stems",
                        preparedStem,
                      );
                    });
                } else {
                  addIfMissing(cve, "vulnerable_product", criteria);
                  addIfMissing(cve, "vulnerable_configuration", criteria);
                  addIfMissing(
                    cve,
                    "vulnerable_configuration_stems",
                    stem(criteria),
                  );
                  handleProductAndVendor(cve, criteria);
                  addIfMissing(cve, "vulnerable_product_stems", stem(criteria));
                }
              } else {
                // Nothing
              }
            } else {
              addIfMissing(cve, "vulnerable_product", criteria);
              addIfMissing(cve, "vulnerable_configuration", criteria);
              addIfMissing(
                cve,
                "vulnerable_configuration_stems",
                stem(criteria),
              );
              handleProductAndVendor(cve, criteria);
              addIfMissing(cve, "vulnerable_product_stems", stem(criteria));
            }
          } else {
            addIfMissing(cve, "vulnerable_configuration", criteria);
            addIfMissing(cve, "vulnerable_configuration_stems", stem(criteria));
          }
        }
      }
    }
  };

  handleChildren = async (item: CVENVD, cve: CVESearch) => {
    // TODO: finish implem
  };
  // ça fait quoi ça ? ça modifie la cve ?? Sauf que handleConfiguration ça ne fait pas d'accès à la DB pour entrer des valeurs...
  // TODO : Demander à Paul
  handleCPE = async (item: CVENVD, cve: CVESearch) => {
    await this.handleConfiguration(item, cve);
    await this.handleChildren(item, cve);
  };
}
