import zlib from "https://deno.land/std@0.177.0/node/zlib.ts";
import { Readable } from "https://deno.land/std@0.177.0/node/stream.ts";
import { CPEFeed, RawCPE } from "./api/feed.ts";
import { SimpleBatcher } from "./utils/batcher.ts";
import { sha1Hex } from "./utils/format.ts";
import { parser, pick, streamArray } from "./utils/streaming.ts";
import { Persistor } from "./utils/persistor.ts";


function generateTitle(cpe: string) {
  let title = "";

  const cpe_split = cpe.split(":");
  // # Do a very basic test to see if the CPE is valid
  if (cpe_split.length == 13) {
    // # Combine vendor, product and version
    title = cpe_split.slice(3, 6).join(" ");

    // # If "other" is specified, add it to the title
    if (cpe_split[12] != "*") {
      title += cpe_split[12];
    }

    // # Capitilize each word
    // title = title.title()

    // # If the target_sw is defined, add "for <target_sw>" to title
    if (cpe_split[10] != "*") {
      title += " for " + cpe_split[10];
    }

    // # In CPE 2.3 spaces are replaced with underscores. Undo it
    title = title.replace("_", " ");

    // # Special characters are escaped with \. Undo it
    title = title.replace("\\", "");
  }

  return title;
}

export type CPE = {
  title: string;
  cpe_2_2: string;
  cpe_name: { cpe23Uri: string }[];
  vendor: string;
  product: string;
  id?: string;
  versionStartExcluding?: string;
  versionStartIncluding?: string;
  versionEndExcluding?: string;
  versionEndIncluding?: string;
};

function executePipeline<T>(
  stream: Readable,
  onItem: (item: T) => void,
) {
  const pipeline = stream
    .pipe(zlib.createGunzip())
    .pipe(parser())
    .pipe(pick({ filter: "matches" }))
    .pipe(streamArray());

  let counter = 0;
  return new Promise<void>((resolve) => {
    pipeline.on("data", ({ value }: { value: T }) => {
      onItem(value);
      ++counter;
    });
    pipeline.on("end", () => {
      resolve();
    });
  });
}

function makeCpeAndVersion(item: RawCPE): [CPE, string] {
  const uri = item.cpe23Uri;
  const cpe: CPE = {
    title: generateTitle(uri),
    cpe_2_2: uri,
    cpe_name: item["cpe_name"],
    vendor: uri.split(":")[3],
    product: uri.split(":")[4],
  };

  let version_info = "";
  if ("versionStartExcluding" in item) {
    cpe["versionStartExcluding"] = item["versionStartExcluding"];
    version_info += cpe["versionStartExcluding"] + "_VSE";
  }

  if ("versionStartIncluding" in item) {
    cpe["versionStartIncluding"] = item["versionStartIncluding"];
    version_info += cpe["versionStartIncluding"] + "_VSI";
  }

  if ("versionEndExcluding" in item) {
    cpe["versionEndExcluding"] = item["versionEndExcluding"];
    version_info += cpe["versionEndExcluding"] + "_VEE";
  }

  if ("versionEndIncluding" in item) {
    cpe["versionEndIncluding"] = item["versionEndIncluding"];
    version_info += cpe["versionEndIncluding"] + "_VEI";
  }

  return [cpe, version_info];
}

function prepareCpeItem(item: RawCPE) {
  const [cpe, version_info] = makeCpeAndVersion(item);
  const sha1Hash = sha1Hex(cpe.cpe_2_2 + version_info);
  cpe.id = sha1Hash;
  return cpe;
}

export class CPEIngester {
  protected batcher: SimpleBatcher<CPE>;
  protected persistor: Persistor<CPE>;

  constructor(
    persistor: Persistor<CPE>,
  ) {
    this.batcher = new SimpleBatcher<CPE>(2000, this.flusher);
    this.persistor = persistor;
    console.log(this.persistor);
  }
  protected upsertData = async (stream: Readable) => {
    await executePipeline(
      stream,
      (item: RawCPE) => this.batcher.enqueue(prepareCpeItem(item)),
    );
  }

  protected flusher = async (batch: CPE[]) => {
    const size = batch.length;
    if (size === 0) {
      return;
    }
    const start = new Date().getTime();
    const batchInsertResult = await this.persistor.persistMany(batch);

    const end = new Date().getTime();
    console.log("batch insert took", end - start, "for", batchInsertResult);
  };

  public async update() {
    const f = new CPEFeed();
    const lastUpdate = new Date(); // TODO: remove stub and fetch from DB
    if (await f.isUpToDate(lastUpdate)) {
      console.log("not up to date, will download");
      const result = await f.get();
      console.log("download done", result);
      // const prepared = toStream(result)
      // const s = new Readable();
      // s.wrap(result);
      await this.upsertData(result);
    }
    await this.batcher.flush();
  }
}
