import { CPEFeed, CPEFeedType, RawCPE } from "./api/feed.ts";
import { sha1Hex } from "./utils/format.ts";
import { SimpleBatcher } from "./utils/batcher.ts";
import { client, newDb } from "./conf.ts";
import { createReadStream, ReadStream } from "https://deno.land/std@0.177.0/node/fs.ts";
import { chain, parser, pick, streamArray, toStream } from "./utils/streaming.ts";
import zlib from "https://deno.land/std/node/zlib.ts";
import { BufReader } from "https://deno.land/std/io/mod.ts";
import { Duplex, Readable, Transform } from "https://deno.land/std@0.177.0/node/stream.ts";
const cpes = newDb.collection("cpes");

function generateTitle(cpe: string) {
    let title = ""

    const cpe_split = cpe.split(":")
    // # Do a very basic test to see if the CPE is valid
    if (cpe_split.length == 13) {
        // # Combine vendor, product and version
        title = cpe_split.slice(3, 6).join(" ");

        // # If "other" is specified, add it to the title
        if (cpe_split[12] != "*") {
            title += cpe_split[12]
        }


        // # Capitilize each word
        // title = title.title()

        // # If the target_sw is defined, add "for <target_sw>" to title
        if (cpe_split[10] != "*") {
            title += " for " + cpe_split[10]
        }


        // # In CPE 2.3 spaces are replaced with underscores. Undo it
        title = title.replace("_", " ")

        // # Special characters are escaped with \. Undo it
        title = title.replace("\\", "")
    }


    console.log('title is', title);
    return title
}

type CPE = {
    title: string;
    cpe_2_2: string;
    cpe_name: { cpe23Uri: string }[];
    vendor: string;
    product: string;
    id?: string;
    versionStartExcluding?: string;
    versionStartIncluding?: string;
    versionEndExcluding?: string;
    versionEndIncluding?: string;
}

function makeTransformer<T, R extends Uint8Array | string>(f: (t: T) => R) {
    return new Transform({
        transform(chunk, encoding, callback) {
            this.push(f(chunk));
            callback();
        }
    });
}

function executePipeline(
    stream: Readable,
    transform: (item: RawCPE) => CPE,
    onItem: (item: CPE) => void,
) {

    const pipeline = stream
        .pipe(zlib.createGunzip())
        .pipe(parser())
        .pipe(pick({ filter: 'matches' }))
        .pipe(streamArray());

    // const pipeline2 = chain([
    //     createReadStream('./src/example/partial-cpe-match.json'),
    //     // createReadStream(),
    //     stream,
    //     zlib.createGunzip(),
    //     parser(),
    //     pick({ filter: 'matches' }),
    //     // pick({ filter:  }),
    //     // ignore({ filter: /\b_meta\b/i }),
    //     streamArray(),
    //     ({ value, key }: { value: RawCPE, key: number }) => {
    //         return transform(value);
    //     }
    // ]);

    let counter = 0;
    return new Promise<void>((resolve) => {
        pipeline.on('data', ({ value }: { value: RawCPE }) => {
            onItem(transform(value));
            ++counter;
        });
        pipeline.on('end', () => {
            resolve();
        });
    });
}




function makeCpeAndVersion(item: RawCPE): [CPE, string] {
    const uri = item.cpe23Uri;
    const cpe: CPE = {
        title: generateTitle(uri),
        cpe_2_2: uri,
        cpe_name: item["cpe_name"],
        vendor: uri.split(":")[3],
        product: uri.split(":")[4],
    }

    let version_info = ""
    if ("versionStartExcluding" in item) {
        cpe["versionStartExcluding"] = item["versionStartExcluding"]
        version_info += cpe["versionStartExcluding"] + "_VSE"
    }

    if ("versionStartIncluding" in item) {
        cpe["versionStartIncluding"] = item["versionStartIncluding"]
        version_info += cpe["versionStartIncluding"] + "_VSI"
    }

    if ("versionEndExcluding" in item) {
        cpe["versionEndExcluding"] = item["versionEndExcluding"]
        version_info += cpe["versionEndExcluding"] + "_VEE"
    }

    if ("versionEndIncluding" in item) {
        cpe["versionEndIncluding"] = item["versionEndIncluding"]
        version_info += cpe["versionEndIncluding"] + "_VEI"
    }

    return [cpe, version_info]
}


function prepareCpeItem(item: any) {
    const [cpe, version_info] = makeCpeAndVersion(item);

    const sha1Hash = sha1Hex(cpe.cpe_2_2 + version_info);

    cpe.id = sha1Hash;

    return cpe;
}


async function flusher(batch: CPE[]) {
    const size = batch.length;
    if (size === 0) {
        return;
    }
    const start = new Date().getTime();
    // const batchInsertResult = await cpes.bulkWrite(batch.map((cpe) => ({
    //     replaceOne: {
    //         filter: { id: cpe.id },
    //         replacement: cpe,
    //         upsert: true,
    //     },
    // })));

    const end = new Date().getTime();
    console.log("batch insert took", end - start, 'for', size);
}
const batcher = new SimpleBatcher<CPE>(2000, flusher);

async function upsertData(stream: Readable) {
    await executePipeline(stream, prepareCpeItem, batcher.enqueue);
    // items.match.forEach(item => {
    //     const prepared = prepareCpeItem(item);
    //     batcher.enqueue(prepared);
    // });
}


export async function populateCpe() {
    // await client.connect();
    const f = new CPEFeed();
    const lastUpdate = new Date(); // TODO: remove stub and fetch from DB
    if (await f.isUpToDate(lastUpdate)) {
        console.log('not up to date, will download');
        const result = await f.get();
        console.log('download done', result);
        // const prepared = toStream(result)
        // const s = new Readable();
        // s.wrap(result);
        await upsertData(result);
    }
    await batcher.flush();
    // await client.close();
    return undefined;
}