// deno-lint-ignore-file require-await 
// @ts-ignore
import { BulkWriteResult, Collection, MongoClient } from "npm:mongodb@5.0.1";
// @ts-ignore
import { Client } from "https://deno.land/x/postgres@v0.17.1/mod.ts";
import { formatDate } from "./format.ts";
import { CPESearch, ExportedCVESearch, MATCHINGSearch } from "./types.ts";

export interface Persistor<
  T,
  Identifier, // should add constraint on > Identifier part of T
> {
  /**
   * Find the first item corresponding to the criteria
   * <p>
   * Can only be found by the identifier
   * @param i
   */
  findOne(i: Identifier): Promise<T | undefined>;
  persistOne(items: T): Promise<boolean>;
  persistMany(items: T[]): Promise<number>;
  open(): Promise<void>;
  close(): Promise<void>;
}

// deno-lint-ignore ban-types
type Obj = {};

type UpdateSchema =  Obj & {id: number, last_update: Date};

// ADDITION //

  // TODO : Rename PersistorFactory
  export interface PgPersistorFactory {
    make<Schema extends Obj, Identifier extends Obj>(
      feedType: string,
      getIdentifier: (t: Schema) => Identifier,
    ): Promise<Persistor<Schema, Identifier>>;
  }
// END ADDITION // 

export interface PersistorFactory {
  make<Schema extends Obj, Identifier extends Obj>(
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>>;
}


function countBulkOperations(result: BulkWriteResult) {
  const { insertedCount, modifiedCount, deletedCount, upsertedCount } = result;
  return (
    insertedCount + modifiedCount + deletedCount + upsertedCount
  );
}

// ADDITION // 
export class PostgrePersistorFactory implements PgPersistorFactory {
  client: Client;
  constructor(client: Client) {
    this.client = client;
  }


  async make<Identifier extends Obj>(feedType: string) : Promise<Persistor<any, Identifier>> {
    if (feedType === "CPE") { 
      const persistor = new CPEPersistor(
        this.client,
      );
      return persistor;
    } else if (feedType === "CVE") {
      const persistor = new CVEPersistor(
        this.client,
      );
      return persistor;
    } else if (feedType === "MATCHING") {
      const persistor = new MatchingPersistor(
        this.client,
      );
      return persistor;
    } else {
      const persistor = new InfosPersistor(
        this.client,
      )
      return persistor;
    }
  }
}

export class CPEPersistor<
Schema extends CPESearch,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
  }

  async persistMany(items: Schema[]): Promise<number> {

    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 5;
      values.push(item.created_at, item.product, item.updated_at, item.version, item.cpe);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5})`;
    }).join(', ');
    const query = `
    INSERT INTO cots (created_at, name, updated_at, version, cpe)
    VALUES ${valuePlaceholders}
    ON CONFLICT (cpe) 
    DO UPDATE
    SET created_at=EXCLUDED.created_at,
    name=EXCLUDED.name,
    updated_at=EXCLUDED.updated_at,
    version=EXCLUDED.version;`;
    
    const res = await this.client.queryArray(query, values);
    console.log(res["rowCount"]);
    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    let column = 'id';
    const query = "SELECT * from cots where $1 = $2";
    let value;

    if ('cpe' in i) {
      column = 'cpe';
      value = i.cpe;
    }
    else if ('id' in i) {
        value = i.id;
      }

    return this.client.queryArray(query, [column, value]);
  }
}

export class MatchingPersistor<
Schema extends MATCHINGSearch,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
    
  }

  async persistMany(items: Schema[]): Promise<number> {

    // Start by adding to table matchings
    const values: any[] = [];
    let valuesMatchings: any[] = [];
    let valueMatchPlaceholders: string[] = []; 
    const valuePlaceholders: string[] = [];
    items.map(async (item) => {
      // We handle matchings
      values.push(item.criteria, item.matchCriteriaId, item.created, item.lastModified, item.cpeLastModified, item.status);
      valuePlaceholders.push(`($${values.length - 5}, $${values.length - 4}::uuid, $${values.length - 3}, $${values.length - 2}, $${values.length - 1}, $${values.length})`);
    })

    const query = `
    INSERT INTO matchings (criteria, uuid, created, last_modified, cpe_last_modified, status)
    VALUES ${valuePlaceholders.join(', ')}
    ON CONFLICT (uuid) 
    DO UPDATE SET
    criteria=EXCLUDED.criteria, created=EXCLUDED.created, last_modified=EXCLUDED.last_modified, cpe_last_modified=EXCLUDED.cpe_last_modified, status=EXCLUDED.status;`;
    let persistCounter = items.length;
    const res = await this.client.queryArray(query, values);
    if (res["rowCount"] != persistCounter) {
      console.log("!!!!!!!!!!!!!!-------MATCHINGS-----!!!!!!!!!!!!!!\nDifference between what should have been added and what was added.\n" + res["rowCount"] + " is what was added and " + persistCounter + " is what should have been added.\n!!!!!!!!!!!!!!------------!!!!!!!!!!!!!!");
    }
    let cpe_matches_counter = 0;
    // We have to do a map twice as we need to have already persisted matchings to link them with cpes 
    
    for (const item of items ){
      // We handle cpe_matches
      if (item.matches != undefined) {
        for (const cpe of item.matches) { 
          // Make sure that we really have a cpeName and not an empty cpe
          if (cpe.cpeName.length > 0) {
            // We may overload the query so we stop at 32000 entries
            if ((valuesMatchings.length/2) > 31998) {
              const returnCount = await this.persistMatchings(valueMatchPlaceholders, valuesMatchings);
              cpe_matches_counter += returnCount;
              valuesMatchings = [];
              valueMatchPlaceholders = [];
            }
            if (item.matchCriteriaId !== undefined && cpe.cpeName !== undefined) {
              valuesMatchings.push(item.matchCriteriaId, cpe.cpeName);
              valueMatchPlaceholders.push(`($${valuesMatchings.length - 1}::uuid, $${valuesMatchings.length})`);
            } else {
              console.log('We got an issue with an item :');
              console.log(item);
              console.log(cpe);
            }
          }
        }
      }
    }
    if (valueMatchPlaceholders.length > 0) {
      const returnCount = await this.persistMatchings(valueMatchPlaceholders, valuesMatchings);
      cpe_matches_counter += returnCount;
    }
    console.log(`Successfully persisted ${persistCounter} matchings and ${cpe_matches_counter} cpe_matches`)
    return (persistCounter+cpe_matches_counter); // Number of insertions done
  }


  // Function to make the request to persist the matchings based on values and placeholders
  async persistMatchings(placeholders, values): Promise<number> {
    //console.log(`We have ${values.length/2} values to insert into cpe_matches`)
    const querymatch = `WITH ins (match_id, cpe) AS
    ( VALUES ${placeholders.join(', ')} )  
    INSERT INTO cpe_matches
    (matching_id, cpe_id) 
    SELECT 
    matchings.id, cots.id
      FROM ins 
        JOIN cots ON cots.cpe = ins.cpe
        JOIN matchings ON matchings.uuid = ins.match_id
      ON CONFLICT (matching_id, cpe_id) DO UPDATE SET matching_id=EXCLUDED.matching_id, cpe_id=EXCLUDED.cpe_id;`

    const res = await this.client.queryArray(querymatch, values);
    if (res["rowCount"] != (values.length)/2) {
      console.log("!!!!!!!!!!!!!!------CPE_MATCHES------!!!!!!!!!!!!!!\nDifference between what should have been added and what was added.\n" + res["rowCount"] + " is what was added and " + ((values.length)/2) + " is what should have been added.\n!!!!!!!!!!!!!!------------!!!!!!!!!!!!!!");
    }
    return res["rowCount"];
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    let column = 'id';
    const query = "SELECT * from matchings where $1 = $2";
    let value;

    if ('match_id' in i) {
      column = 'match_id';
      value = i.match_id;
    }
    else if ('id' in i) {
        value = i.id;
      }

    return this.client.queryArray(query, [column, value]);
  }
}



export class CVEPersistor<
Schema extends ExportedCVESearch,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
  }
   // TODO : Regarder pour un query builder
  // TODO : process properly the items (put it in a list that is in the right order and seperate properly the items) 
  // TODO : Lister toutes les tables qu'il faut nourrir avec CVE => CVE assigner CVSS3 Mark CVSS2 MArk ....
  async persistMany(items: Schema[]): Promise<number> {
    
    //this.persistCVETable(items);
    // this.persistCVEImpact(items);
    // this.persistCVEAccess(items);
    //this.persistCVSS3(items);
    // this.persistCVSS2(items);
    this.persistCVEVulnConf(items);

    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    let column = 'id';
    const query = "SELECT * from cve where $1 = $2";
    let value;

    if ('name' in i) {
      column = 'name';
      value = i.name;
    }

    else if ('id' in i) {
        value = i.id;
      }

    return this.client.queryArray(query, [column, value]);
  }

  async persistCVETable(items: Schema[]) {
    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 6;
      values.push(item.cwe, item.last_modified, item.Modified, item.id, item.Published, item.summary);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5}, $${baseIndex + 6})`;
    }).join(', ');
    const query = `
    INSERT INTO cve (cwe,last_modified, modified, name, published, summary)
    VALUES ${valuePlaceholders}
    ON CONFLICT (name) 
    DO NOTHING;`;

    await this.client.queryArray(query, values);
    return items.length; // Number of insertions done

  }
  persistCVEImpact(items: Schema[]) {
    console.log(`name: ${items[20]}`)
  }
  persistCVEAccess(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVSS3(items: Schema[]) {
   
    // item.impact3 : { availability: "NONE", confidentiality: "LOW", integrity: "LOW" }
    // item.exploitability3 : {
        // attackvector: "LOCAL",
        // attackcomplexity: "HIGH",
        // privilegesrequired: "HIGH",
        // userinteraction: "REQUIRED",
        // scope: "CHANGED" }
    // item.cvss3 : 3.9
    // item.impactScore3 : 2.7
    // item.exploitabilityScore3 : 0.6


    console.log(items[5])
  }
  persistCVSS2(items: Schema[]) {
    // item.access: { authentication: "NONE", complexity: "LOW", vector: "NETWORK" }
    // item.impact : { availability: "NONE", confidentiality: "LOW", integrity: "LOW" }
    // item.cvss : 3.9
    // item.impactScore3 : 2.7
    // item.exploitabilityScore3 : 0.6
  }
  persistCVEVulnProducts(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }

  persistCVEVulnConf(items: Schema[]) {
    console.log("PROUT CACA BOUDAING !")
    console.log(items[0].matches)
    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 6;

      values.push(item.cwe, item.last_modified, item.Modified, item.id, item.Published, item.summary);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5}, $${baseIndex + 6})`;
    }).join(', ');
    const query = `WITH ins (match_uuid, cve_name) AS
    ( VALUES ${valuePlaceholders} )  
    INSERT INTO cots_cves
    (cots_id, cve_id) 
    SELECT 
    cpe_matches.cpe_id, cve.id
      FROM ins 
        JOIN cve ON cve.name = ins.cve_name
        JOIN matchings ON matchings.uuid = ins.match_uuid
        JOIN cpe_matches ON cpe_matches.matching_id = matchings.id
      ON CONFLICT (cots_id, cve_id) DO NOTHING;`;

    this.client.queryArray(query, values);
  }
  persistCVEVendors(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }

  persistCVEProducts(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
}

  // END ADDITION //

export class InfosPersistor<
Schema extends UpdateSchema,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  client: Client;

  constructor(
    client: Client, 
  ) {
    this.client = client;
    
  }
  async persistMany(items: Schema[]): Promise<number> {
    console.log("This should not ever be called")
    //this.client.query(`INSERT INTO Table2 values ....`)
    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  async persistOne(item: Schema): Promise<boolean> {
    const res = await this.client.queryObject(`UPDATE updates SET last_update='${formatDate(item.last_update)}' where id=${item.id}`);
    return res.rows.length;
  }

  close(): Promise<void> {
    return this.client.end();
  }

  async findOne(i: Identifier): Promise<Schema | undefined> {
    const res = await this.client.queryObject(`select last_update from updates where id = ${i}`);
    return res.rows[0];
  }
}
/**
 * Persists the data to a mongo collection using a configured mongo client
*/
export class MongoPersistor<
DatabaseName extends string,
CollectionName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  collectionName: CollectionName;
  getIdentifier: (t: Schema) => Identifier;
  client: MongoClient;
  collection: Collection;

  constructor(
    databaseName: DatabaseName,
    collection: CollectionName,
    getIdentifier: (t: Schema) => Identifier,
    client: MongoClient,
  ) {
    this.databaseName = databaseName;
    this.collectionName = collection;
    this.getIdentifier = getIdentifier;
    this.client = client;
    this.collection = this.client.db(this.databaseName).collection(
      this.collectionName,
    );
  }

  async persistMany(items: Schema[]): Promise<number> {
    const bulk = items.map((item) => ({
      replaceOne: {
        filter: this.getIdentifier(item),
        replacement: item,
        upsert: true,
      },
    }));
    const batchInsertResult = await this.collection.bulkWrite(
      bulk,
    );
    return countBulkOperations(batchInsertResult);
  }
  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.close();
  }
  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.collection.findOne(i) as unknown as Promise<Schema | undefined>;
  }
}
