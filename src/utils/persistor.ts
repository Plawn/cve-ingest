// deno-lint-ignore-file require-await
import { BulkWriteResult, Collection, MongoClient } from "npm:mongodb@5.0.1";
import { Client } from "https://deno.land/x/postgres@v0.17.1/mod.ts";
import { formatDate } from "./format.ts";

export interface Persistor<
  T,
  Identifier, // should add constraint on > Identifier part of T
> {
  /**
   * Find the first item corresponding to the criteria
   * <p>
   * Can only be found by the identifier
   * @param i
   */
  findOne(i: Identifier): Promise<T | undefined>;
  persistOne(items: T): Promise<boolean>;
  persistMany(items: T[]): Promise<number>;
  open(): Promise<void>;
  close(): Promise<void>;
}

// deno-lint-ignore ban-types
type Obj = {};

type UpdateSchema =  Obj & {id: number, last_update: Date};

// ADDITION //

  // TODO : Rename PersistorFactory
  export interface PgPersistorFactory {
    make<Schema extends Obj, Identifier extends Obj>(
      databaseName: string,
      feedType: string,
      getIdentifier: (t: Schema) => Identifier,
    ): Promise<Persistor<Schema, Identifier>>;
  }
// END ADDITION // 

export interface PersistorFactory {
  make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>>;
}

export class DebugPersistorFactory implements PersistorFactory {
  async make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>> {
    return new DebugPersistor(databaseName, collectionName, getIdentifier);
  }
}



export class MongoPersistorFactory implements PersistorFactory {
  client: MongoClient;
  constructor(client: MongoClient) {
    this.client = client;
  }

  async make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>> {
    const persistor = new MongoPersistor(
      databaseName,
      collectionName,
      getIdentifier,
      this.client,
    );
    
    return persistor;
  }
}

function countBulkOperations(result: BulkWriteResult) {
  const { insertedCount, modifiedCount, deletedCount, upsertedCount } = result;
  return (
    insertedCount + modifiedCount + deletedCount + upsertedCount
  );
}

/**
 * This only prints to log the data that should have been persisted
*/
export class DebugPersistor<T, I> implements Persistor<T, I> {
  databaseName: string;
  collectionName: string;
  getIdentifier: (t: T) => I;
  constructor(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: T) => I,
  ) {
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.getIdentifier = getIdentifier;
  }
  
  async persistMany(items: T[]): Promise<number> {
    console.log(items);
    return items.length;
  }
  
  async findOne(_i: I): Promise<T | undefined> {
    return undefined;
  }
  
  async persistOne(items: T): Promise<boolean> {
    await this.persistMany([items]);
    return true;
  }
  async close(): Promise<void> {
    return undefined;
  }
  
  async open(): Promise<void> {
    return undefined;
  }
}

// ADDITION // 
export class PostgrePersistorFactory implements PgPersistorFactory {
  client: Client;
  constructor(client: Client) {
    this.client = client;
  }


  async make<Schema extends Obj, Identifier extends Obj>(databaseName: string, feedType: string) : Promise<Persistor<Schema, Identifier>> {
    if (feedType === "CPE") { 
      const persistor = new CPEPersistor(
        databaseName,
        this.client,
      );
      return persistor;
    } else if (feedType === "CVE") {
      const persistor = new CVEPersistor(
        databaseName,
        this.client,
      );
      return persistor;
    } else {
      const persistor = new InfosPersistor(
        databaseName,
        this.client,
      )
      return persistor;
    }
  }
}

export class CPEPersistor<
DatabaseName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  client: Client;

  constructor(
    databaseName: DatabaseName,
    client: Client, 
  ) {
    this.databaseName = databaseName;
    this.client = client;
    
  }

  async persistMany(items: Schema[]): Promise<number> {

    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 5;
      values.push(item.created_at, item.product, item.updated_at, item.version, item.cpe);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5})`;
    }).join(', ');
    const query = `
    INSERT INTO cots (created_at, name, updated_at, version, cpe)
    VALUES ${valuePlaceholders}
    ON CONFLICT (cpe) 
    DO NOTHING;`;

    await this.client.queryArray(query, values);
    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  // TODO : Use a Query builder
  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.client.queryArray(`use a query builder ! `) as unknown as Promise<Schema | undefined>;
  }
}

export class CVEPersistor<
DatabaseName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  client: Client;

  constructor(
    databaseName: DatabaseName,
    client: Client, 
  ) {
    this.databaseName = databaseName;
    this.client = client;
    
  }
   // TODO : Regarder pour un query builder
  // TODO : process properly the items (put it in a list that is in the right order and seperate properly the items) 
  // TODO : Lister toutes les tables qu'il faut nourrir avec CVE => CVE assigner CVSS3 Mark CVSS2 MArk ....
  async persistMany(items: Schema[]): Promise<number> {
    
    this.persistCVETable(items);
    // this.persistCVEImpact(items);
    // this.persistCVEAccess(items);
    // this.persistCVSS3(items);
    // this.persistCVSS2(items);
    // this.persistCVEVulnProducts(items);
    // this.persistCVEVulnConf(items);
    // this.persistCVEVendors(items);
    // this.persistCVEProducts(items);

    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.client.queryArray(`select * from cve where name=${i.name}`) as unknown as Promise<Schema | undefined>;
  }
  async persistCVETable(items: Schema[]) {
    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 6;
      values.push(item.cwe, item.last_modified, item.Modified, item.id, item.Published, item.summary);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5}, $${baseIndex + 6})`;
    }).join(', ');
    const query = `
    INSERT INTO cve (cwe,last_modified, modified, name, published, summary)
    VALUES ${valuePlaceholders}
    ON CONFLICT (name) 
    DO NOTHING;`;

    await this.client.queryArray(query, values);
    return items.length; // Number of insertions done

  }
  persistCVEImpact(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVEAccess(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVSS3(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVSS2(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVEVulnProducts(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }

  persistCVEVulnConf(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVEVendors(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }

  persistCVEProducts(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
}

  // END ADDITION //

export class InfosPersistor<
DatabaseName extends string,
Schema extends UpdateSchema,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  client: Client;

  constructor(
    databaseName: DatabaseName,
    client: Client, 
  ) {
    this.databaseName = databaseName;
    this.client = client;
    
  }
  async persistMany(items: Schema[]): Promise<number> {
    console.log("This should not ever be called")
    //this.client.query(`INSERT INTO Table2 values ....`)
    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  async persistOne(item: Schema): Promise<boolean> {
    const res = await this.client.queryObject(`UPDATE updates SET last_update='${formatDate(item.last_update)}' where id=${item.id}`);
    return res.rows.length;
  }

  close(): Promise<void> {
    return this.client.end();
  }

  async findOne(i: Identifier): Promise<Schema | undefined> {
    const res = await this.client.queryObject(`select last_update from updates where id = ${i}`);
    return res.rows[0];
  }
}
/**
 * Persists the data to a mongo collection using a configured mongo client
*/
export class MongoPersistor<
DatabaseName extends string,
CollectionName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  collectionName: CollectionName;
  getIdentifier: (t: Schema) => Identifier;
  client: MongoClient;
  collection: Collection;

  constructor(
    databaseName: DatabaseName,
    collection: CollectionName,
    getIdentifier: (t: Schema) => Identifier,
    client: MongoClient,
  ) {
    this.databaseName = databaseName;
    this.collectionName = collection;
    this.getIdentifier = getIdentifier;
    this.client = client;
    this.collection = this.client.db(this.databaseName).collection(
      this.collectionName,
    );
  }

  async persistMany(items: Schema[]): Promise<number> {
    const bulk = items.map((item) => ({
      replaceOne: {
        filter: this.getIdentifier(item),
        replacement: item,
        upsert: true,
      },
    }));
    const batchInsertResult = await this.collection.bulkWrite(
      bulk,
    );
    return countBulkOperations(batchInsertResult);
  }
  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.close();
  }
  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.collection.findOne(i) as unknown as Promise<Schema | undefined>;
  }
}
