// deno-lint-ignore-file require-await
import { BulkWriteResult, Collection, MongoClient } from "npm:mongodb@5.0.1";
import { Client } from "https://deno.land/x/postgres@v0.17.1/mod.ts";
import { formatDate } from "./format.ts";
import { emptyArray } from "./utils.ts";

export interface Persistor<
  T,
  Identifier, // should add constraint on > Identifier part of T
> {
  /**
   * Find the first item corresponding to the criteria
   * <p>
   * Can only be found by the identifier
   * @param i
   */
  findOne(i: Identifier): Promise<T | undefined>;
  persistOne(items: T): Promise<boolean>;
  persistMany(items: T[]): Promise<number>;
  open(): Promise<void>;
  close(): Promise<void>;
}

// deno-lint-ignore ban-types
type Obj = {};

type UpdateSchema =  Obj & {id: number, last_update: Date};

// ADDITION //

  // TODO : Rename PersistorFactory
  export interface PgPersistorFactory {
    make<Schema extends Obj, Identifier extends Obj>(
      databaseName: string,
      feedType: string,
      getIdentifier: (t: Schema) => Identifier,
    ): Promise<Persistor<Schema, Identifier>>;
  }
// END ADDITION // 

export interface PersistorFactory {
  make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>>;
}

export class DebugPersistorFactory implements PersistorFactory {
  async make<Schema extends Obj, Identifier extends Obj>(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: Schema) => Identifier,
  ): Promise<Persistor<Schema, Identifier>> {
    return new DebugPersistor(databaseName, collectionName, getIdentifier);
  }
}



function countBulkOperations(result: BulkWriteResult) {
  const { insertedCount, modifiedCount, deletedCount, upsertedCount } = result;
  return (
    insertedCount + modifiedCount + deletedCount + upsertedCount
  );
}

/**
 * This only prints to log the data that should have been persisted
*/
export class DebugPersistor<T, I> implements Persistor<T, I> {
  databaseName: string;
  collectionName: string;
  getIdentifier: (t: T) => I;
  constructor(
    databaseName: string,
    collectionName: string,
    getIdentifier: (t: T) => I,
  ) {
    this.databaseName = databaseName;
    this.collectionName = collectionName;
    this.getIdentifier = getIdentifier;
  }
  
  async persistMany(items: T[]): Promise<number> {
    console.log(items);
    return items.length;
  }
  
  async findOne(_i: I): Promise<T | undefined> {
    return undefined;
  }
  
  async persistOne(items: T): Promise<boolean> {
    await this.persistMany([items]);
    return true;
  }
  async close(): Promise<void> {
    return undefined;
  }
  
  async open(): Promise<void> {
    return undefined;
  }
}

// ADDITION // 
export class PostgrePersistorFactory implements PgPersistorFactory {
  client: Client;
  constructor(client: Client) {
    this.client = client;
  }


  async make<Schema extends Obj, Identifier extends Obj>(databaseName: string, feedType: string) : Promise<Persistor<Schema, Identifier>> {
    if (feedType === "CPE") { 
      const persistor = new CPEPersistor(
        databaseName,
        this.client,
      );
      return persistor;
    } else if (feedType === "CVE") {
      const persistor = new CVEPersistor(
        databaseName,
        this.client,
      );
      return persistor;
    } else if (feedType === "MATCHING") {
      const persistor = new MatchingPersistor(
        databaseName,
        this.client,
      );
      return persistor;
    } else {
      const persistor = new InfosPersistor(
        databaseName,
        this.client,
      )
      return persistor;
    }
  }
}

export class CPEPersistor<
DatabaseName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  client: Client;

  constructor(
    databaseName: DatabaseName,
    client: Client, 
  ) {
    this.databaseName = databaseName;
    this.client = client;
    
  }

  async persistMany(items: Schema[]): Promise<number> {

    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 5;
      values.push(item.created_at, item.product, item.updated_at, item.version, item.cpe);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5})`;
    }).join(', ');
    const query = `
    INSERT INTO cots (created_at, name, updated_at, version, cpe)
    VALUES ${valuePlaceholders}
    ON CONFLICT (cpe) 
    DO NOTHING;`;

    await this.client.queryArray(query, values);
    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  // TODO : Use a Query builder
  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.client.queryArray(`use a query builder ! `) as unknown as Promise<Schema | undefined>;
  }
}

export class MatchingPersistor<
DatabaseName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  client: Client;

  constructor(
    databaseName: DatabaseName,
    client: Client, 
  ) {
    this.databaseName = databaseName;
    this.client = client;
    
  }

  async persistMany(items: Schema[]): Promise<number> {

    // Start by adding to table matchings
    const values: any[] = [];
    let valuesMatchings: any[] = [];
    let valueMatchPlaceholders: string[] = []; 
    const valuePlaceholders: string[] = [];
    
    items.map(async (item) => {

      // We handle cpe_matches
      if (item.matches != undefined) {
        for (const cpe of item.matches) { 
          // Make sure that we really have a cpeName and not an empty cpe
          if (cpe.cpeName.length > 0) {
            // We may overload the query so we stop at 3800 entries
            if (valuesMatchings.length > 31998) {
              await this.persistMatchings(valueMatchPlaceholders, valuesMatchings);
              valuesMatchings = [];
              valueMatchPlaceholders = [];
            }
            valuesMatchings.push(item.criteria, cpe.cpeName);
            valueMatchPlaceholders.push(`($${valuesMatchings.length - 1}, $${valuesMatchings.length})`);
          }
        }
      }
      // We handle matchings
      values.push(item.criteria, item.created, item.last_modified, item.cpe_last_modified, item.status);
      valuePlaceholders.push(`($${values.length - 4}, $${values.length - 3}, $${values.length - 2}, $${values.length - 1}, $${values.length})`);
    })

    const query = `
    INSERT INTO matchings (criteria, created, last_modified, cpe_last_modified, status)
    VALUES ${valuePlaceholders.join(', ')}
    ON CONFLICT (criteria) 
    DO NOTHING;`;

    await this.client.queryArray(query, values);

    if (valueMatchPlaceholders.length > 0) {
      await this.persistMatchings(valueMatchPlaceholders, valuesMatchings);
    }
    return items.length; // Number of insertions done
  }
  // Function to make the request to persist the matchings based on values and placeholders
  async persistMatchings(placeholders, values): Promise<void> {
    console.log(`We have ${values.length} values to insert`)
    const querymatch = `WITH ins (criteria, cpe) AS
    ( VALUES ${placeholders.join(', ')} )  
    INSERT INTO cpe_matches
    (matching_id, cpe_id) 
    SELECT 
    matchings.id, cots.id
      FROM ins 
        JOIN cots ON cots.cpe = ins.cpe
        JOIN matchings ON matchings.criteria = ins.criteria
      ON CONFLICT DO NOTHING;`
      await this.client.queryArray(querymatch, values);
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  // TODO : Use a Query builder
  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.client.queryArray(`use a query builder ! `) as unknown as Promise<Schema | undefined>;
  }
}



export class CVEPersistor<
DatabaseName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  client: Client;

  constructor(
    databaseName: DatabaseName,
    client: Client, 
  ) {
    this.databaseName = databaseName;
    this.client = client;
    
  }
   // TODO : Regarder pour un query builder
  // TODO : process properly the items (put it in a list that is in the right order and seperate properly the items) 
  // TODO : Lister toutes les tables qu'il faut nourrir avec CVE => CVE assigner CVSS3 Mark CVSS2 MArk ....
  async persistMany(items: Schema[]): Promise<number> {
    
    this.persistCVETable(items);
    // this.persistCVEImpact(items);
    // this.persistCVEAccess(items);
    this.persistCVSS3(items);
    // this.persistCVSS2(items);
    // this.persistCVEVulnProducts(items);
    // this.persistCVEVulnConf(items);
    // this.persistCVEVendors(items);
    // this.persistCVEProducts(items);

    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.end();
  }

  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.client.queryArray(`select * from cve where name=${i.name}`) as unknown as Promise<Schema | undefined>;
  }
  async persistCVETable(items: Schema[]) {
    const values: any[] = [];
    const valuePlaceholders = items.map((item, index) => {
      const baseIndex = index * 6;
      values.push(item.cwe, item.last_modified, item.Modified, item.id, item.Published, item.summary);
      return `($${baseIndex + 1}, $${baseIndex + 2}, $${baseIndex + 3}, $${baseIndex + 4}, $${baseIndex + 5}, $${baseIndex + 6})`;
    }).join(', ');
    const query = `
    INSERT INTO cve (cwe,last_modified, modified, name, published, summary)
    VALUES ${valuePlaceholders}
    ON CONFLICT (name) 
    DO NOTHING;`;

    await this.client.queryArray(query, values);
    return items.length; // Number of insertions done

  }
  persistCVEImpact(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVEAccess(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVSS3(items: Schema[]) {
   
    // item.impact3 : { availability: "NONE", confidentiality: "LOW", integrity: "LOW" }
    // item.exploitability3 : {
        // attackvector: "LOCAL",
        // attackcomplexity: "HIGH",
        // privilegesrequired: "HIGH",
        // userinteraction: "REQUIRED",
        // scope: "CHANGED" }
    // item.cvss3 : 3.9
    // item.impactScore3 : 2.7
    // item.exploitabilityScore3 : 0.6


    console.log(items[0])
  }
  persistCVSS2(items: Schema[]) {
    // item.access: { authentication: "NONE", complexity: "LOW", vector: "NETWORK" }
    // item.impact : { availability: "NONE", confidentiality: "LOW", integrity: "LOW" }
    // item.cvss : 3.9
    // item.impactScore3 : 2.7
    // item.exploitabilityScore3 : 0.6
  }
  persistCVEVulnProducts(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }

  persistCVEVulnConf(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
  persistCVEVendors(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }

  persistCVEProducts(items: Schema[]) {
    console.log(`name: ${items[0].id}`)
  }
}

  // END ADDITION //

export class InfosPersistor<
DatabaseName extends string,
Schema extends UpdateSchema,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  client: Client;

  constructor(
    databaseName: DatabaseName,
    client: Client, 
  ) {
    this.databaseName = databaseName;
    this.client = client;
    
  }
  async persistMany(items: Schema[]): Promise<number> {
    console.log("This should not ever be called")
    //this.client.query(`INSERT INTO Table2 values ....`)
    return items.length; // Number of insertions done
  }

  async open(): Promise<void> {
    await this.client.connect();
  }

  async persistOne(item: Schema): Promise<boolean> {
    const res = await this.client.queryObject(`UPDATE updates SET last_update='${formatDate(item.last_update)}' where id=${item.id}`);
    return res.rows.length;
  }

  close(): Promise<void> {
    return this.client.end();
  }

  async findOne(i: Identifier): Promise<Schema | undefined> {
    const res = await this.client.queryObject(`select last_update from updates where id = ${i}`);
    return res.rows[0];
  }
}
/**
 * Persists the data to a mongo collection using a configured mongo client
*/
export class MongoPersistor<
DatabaseName extends string,
CollectionName extends string,
Schema extends Obj,
Identifier extends Obj,
> implements Persistor<Schema, Identifier> {
  databaseName: DatabaseName;
  collectionName: CollectionName;
  getIdentifier: (t: Schema) => Identifier;
  client: MongoClient;
  collection: Collection;

  constructor(
    databaseName: DatabaseName,
    collection: CollectionName,
    getIdentifier: (t: Schema) => Identifier,
    client: MongoClient,
  ) {
    this.databaseName = databaseName;
    this.collectionName = collection;
    this.getIdentifier = getIdentifier;
    this.client = client;
    this.collection = this.client.db(this.databaseName).collection(
      this.collectionName,
    );
  }

  async persistMany(items: Schema[]): Promise<number> {
    const bulk = items.map((item) => ({
      replaceOne: {
        filter: this.getIdentifier(item),
        replacement: item,
        upsert: true,
      },
    }));
    const batchInsertResult = await this.collection.bulkWrite(
      bulk,
    );
    return countBulkOperations(batchInsertResult);
  }
  async open(): Promise<void> {
    await this.client.connect();
  }

  persistOne(items: Schema): Promise<boolean> {
    return this.persistMany([items]).then((e) => e === 1);
  }

  close(): Promise<void> {
    return this.client.close();
  }
  findOne(i: Identifier): Promise<Schema | undefined> {
    return this.collection.findOne(i) as unknown as Promise<Schema | undefined>;
  }
}
