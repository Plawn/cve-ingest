import STREAM_CHAIN from "npm:stream-chain";
import PARSER from "npm:stream-json";
import PICK from "npm:stream-json/filters/Pick.js";
import IGNORE from "npm:stream-json/filters/Ignore.js";
import STREAM_VALUES from "npm:stream-json/streamers/StreamValues.js";
import STREAM_ARRAY from "npm:stream-json/streamers/StreamArray.js";
import { Readable } from "https://deno.land/std@0.177.0/node/stream.ts";
import zlib from "https://deno.land/std@0.177.0/node/zlib.ts";
// Here we hide the shady stuff we have to do to export the npm modules

const chain = STREAM_CHAIN.chain;
const parser = PARSER.parser;
const pick = PICK.pick;
const ignore = IGNORE.ignore;
const streamValues = STREAM_VALUES.streamValues;
const streamArray = STREAM_ARRAY.streamArray;

export { chain, ignore, parser, pick, streamArray, streamValues };

// export function plainStreamArrayExtractor<T, K extends keyof T>(stream: Readable, key: K) {
//     const pipeline = stream // here we have a stream of bytes
//         .pipe(parser()) // stream the bytes of the first file into a parser
//         .pipe(pick({ filter: key })) // takes the entry called "matches"
//         .pipe(streamArray()); // takes the entries of "matches" and stream each token
//     return pipeline as Readable;
// }

export function tarGzStreamArrayExtractor<T, K extends keyof T = keyof T>(
  stream: Readable,
  key: K,
) {
  const pipeline = stream // here we have a stream of bytes
    .pipe(zlib.createGunzip()) // take the tar.gz archive and stream the content of the archive
    .pipe(parser()) // stream the bytes of the first file into a parser
    .pipe(pick({ filter: key })) // takes the entry called "matches"
    .pipe(streamArray()); // takes the entries of "matches" and stream each token
  return pipeline as Readable;
}

export function blobTarGzStreamArrayExtractor<T, K extends keyof T = keyof T>(
  blob: Blob,
  key: K,
) {
  const pipeline = Readable.from(blob.stream()) // here we have a stream of bytes
    .pipe(zlib.createGunzip()) // take the tar.gz archive and stream the content of the archive
    .pipe(parser()) // stream the bytes of the first file into a parser
    .pipe(pick({ filter: key })) // takes the entry called "matches"
    .pipe(streamArray()); // takes the entries of "matches" and stream each token
  return pipeline as Readable;
}
