import { Buffer } from "https://deno.land/std@0.139.0/node/buffer.ts";
import { readableStreamFromIterable } from "https://deno.land/std@0.136.0/streams/mod.ts";
import { createReadStream, createWriteStream } from "https://deno.land/std@0.177.0/node/fs.ts";
import { readableStreamFromReader } from "https://deno.land/std@0.156.0/streams/mod.ts?s=readableStreamFromReader";

import { Duplex, PassThrough, Readable, Writable } from "https://deno.land/std@0.177.0/node/stream.ts";

import streamBuffers from 'npm:stream-buffers';
import { waiting, sleep } from "../utils/pool.ts";


export interface Feed<T> {
  isUpToDate(date: Date): Promise<boolean>;
  get(): Promise<T>;
}
export type RawCPE = {
  cpe23Uri: string;
  cpe_name: { cpe23Uri: string }[];

  versionStartExcluding?: string;
  versionStartIncluding?: string;
  versionEndExcluding?: string;
  versionEndIncluding?: string;
};

export type CPEFeedType = {
  matches: RawCPE[];
};


class Progress {
  total: number = 0;
  current: number = 0;
  done: boolean = false;
  constructor() {

  }
  end = () => {
    this.done = true;
  }
  add(n: number) {
    this.current += n;
  }
}

async function myReadbleStream(blob: Blob) {
  const buffSize = 1024 * 10;
  let start = 0;
  let end = buffSize;
  const data: ArrayBuffer[] = [];
  while (true) {
    const slice = blob.slice(start, end);
    const buf = await slice.arrayBuffer();
    if (slice.size === 0) {
      break;
    }
    data.push(new Uint8Array(buf));
    start += buffSize;
    end += buffSize;
  }

  return new Readable({
    read() {
      if (data.length === 0) {
        this.push(null);
        console.log('all data is pushed');
      } else {

        if (waiting.get() > 3) {
          console.log('slow');
          setTimeout(() => this.push(data.shift()), 1000);
        } else {
          if (data.length % 100) {
            setTimeout(() => this.push(data.shift()), 100);
          } else {
            this.push(data.shift())
          }
        }
      }
    }
  })
}

function pumpedStreamedBody(response: Response): [PassThrough, Progress] {
  const reader = response.body!.getReader();

  // Step 2: get total length
  const contentLength = +response.headers.get('Content-Length')!;

  const tunnel = new PassThrough();
  const progress = new Progress();
  progress.total = contentLength;
  (async () => {
    while (true) {
      const { done, value } = await reader.read();

      if (done) {
        tunnel.end();
        break;
      }
      progress.add(value.length);
      tunnel.write(value);
    }
  })()
  return [tunnel, progress];
}

export class CPEFeed {
  url = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz";
  getUpdateDate(r: Response): Date | undefined {
    const h = r.headers.get("last-modified");
    if (h) {
      return new Date(h);
    }
    return undefined;
  }

  async isUpToDate(date: Date) {
    const resp = await fetch(this.url, {
      method: "HEAD",
    });
    const currentLastUpdate = this.getUpdateDate(resp);
    console.log(resp.status);
    if (currentLastUpdate!.getTime() > date.getTime()) {
      return false;
    }
    return true;
  }

  async get() {
    const response = await fetch(this.url);
    const file = await Deno.open('./res', { create: true, write: true, read: true })
    // const [tunnel, progress] = pumpedStreamedBody(response);
    // await response.body?.pipeTo(file.writable);
    const blob = await response.blob();
    console.log('file downloaded');
    return myReadbleStream(blob);
  }
}
