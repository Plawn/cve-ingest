import { Buffer } from "https://deno.land/std@0.139.0/node/buffer.ts";
import { readableStreamFromIterable } from "https://deno.land/std@0.136.0/streams/mod.ts";
import { createReadStream } from "https://deno.land/std@0.177.0/node/fs.ts";

import { Duplex, PassThrough, Readable, Writable } from "https://deno.land/std@0.177.0/node/stream.ts";


export interface Feed<T> {
  isUpToDate(date: Date): Promise<boolean>;
  get(): Promise<T>;
}
export type RawCPE = {
  cpe23Uri: string;
  cpe_name: { cpe23Uri: string }[];

  versionStartExcluding?: string;
  versionStartIncluding?: string;
  versionEndExcluding?: string;
  versionEndIncluding?: string;
};

export type CPEFeedType = {
  matches: RawCPE[];
};


class Progress {
  total: number = 0;
  current: number = 0;
  done: boolean = false;
  constructor() {

  }
  end = () => {
    this.done = true;
  }
  add(n: number) {
    this.current += n;
  }
}

function pumpedStreamedBody(response: Response): [PassThrough, Progress] {
  const reader = response.body!.getReader();

  // Step 2: get total length
  const contentLength = +response.headers.get('Content-Length')!;

  const tunnel = new PassThrough();
  const progress = new Progress();
  progress.total = contentLength;
  (async () => {
    while (true) {
      const { done, value } = await reader.read();

      if (done) {
        tunnel.end();
        break;
      }
      progress.add(value.length);
      tunnel.write(value);
    }
  })()
  return [tunnel, progress];
}

export class CPEFeed {
  url = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz";
  getUpdateDate(r: Response): Date | undefined {
    const h = r.headers.get("last-modified");
    if (h) {
      return new Date(h);
    }
    return undefined;
  }

  async isUpToDate(date: Date) {
    const resp = await fetch(this.url, {
      method: "HEAD",
    });
    const currentLastUpdate = this.getUpdateDate(resp);
    console.log(resp.status);
    if (currentLastUpdate!.getTime() > date.getTime()) {
      return false;
    }
    return true;
  }

  async get() {
    const response = await fetch(this.url);
    const blob = await response.blob();
    // TODO: make this cleaner and avoid storing the data on disk
    await Deno.writeFile('res', Buffer.from(await blob.arrayBuffer()))
    console.log('archive downloaded');
    // ensure the file is fully downloaded to avoid timeout and back pressure issues
    return createReadStream('res');
  }
}
